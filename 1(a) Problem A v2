# Bisection Method in Maple
Bisection := proc(f, a, b, tol)
    local l, r, p, N, fp, nsteps;

    # Compute the theoretical number of steps needed
    nsteps := ceil( evalf( ln((b - a)/tol)/ln(2) ) );
    printf("Theoretical number of steps needed: %d\n\n", nsteps);

    # Initialize endpoints and counter
    l := a;
    r := b;
    N := 1;

    # Print table header
    printf(" n        a            b            p            f(p)\n");
    printf("---------------------------------------------------------\n");

    # Loop until interval is small enough or 20 steps reached
    while (r - l > tol) and (N <= 20) do

        # Midpoint
        p := (l + r)/2;
        fp := f(p);

        # Print row of table
        printf("%2d   %10.6f   %10.6f   %10.6f   %12.8f\n", 
               N, l, r, p, fp);

        # Bisection step
        if fp = 0 then
            return p;
        elif f(l)*fp < 0 then
            r := p;
        else
            l := p;
        end if;

        N := N + 1;
    end do;

    printf("\nFinal approximation after %d iterations: %f\n",
           N-1, (l+r)/2);

    return (l+r)/2;
end proc:

# Problem (a): f(x) = e^(-x) - sin(x)
f := x -> exp(-x) - sin(x);

# Run on [0.5, 1] with tolerance 1e-4
root_a := Bisection(f, 0.5, 1, 1e-4);
